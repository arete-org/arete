import { FormEvent, useEffect, useMemo, useRef, useState } from 'react';

// Provide a stable fallback response in case the backend is unavailable so the space stays welcoming.
const FALLBACK_REFLECTION =
  'Even without a live connection, remember: quiet consistency is the soil where trust grows.';

const MeetDaneel = (): JSX.Element => {
  const [question, setQuestion] = useState('');
  const [status, setStatus] = useState('Offer a question about values, choices, or change — and I’ll return a short note.');
  const [answer, setAnswer] = useState('');
  const [displayedAnswer, setDisplayedAnswer] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const abortRef = useRef<AbortController | null>(null);
  const inputRef = useRef<HTMLInputElement | null>(null);

  // Animate the text reveal whenever the answer changes for a gentle typewriter feel.
  useEffect(() => {
    if (!answer) {
      setDisplayedAnswer('');
      return;
    }

    setDisplayedAnswer('');
    const characters = Array.from(answer);
    let index = 0;

    const interval = window.setInterval(() => {
      setDisplayedAnswer((previous) => previous + characters[index]);
      index += 1;

      if (index >= characters.length) {
        window.clearInterval(interval);
      }
    }, 22);

    return () => window.clearInterval(interval);
  }, [answer]);

  const onSubmit = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const trimmedQuestion = question.trim();

    if (!trimmedQuestion) {
      setStatus('Please share a question, even a small one.');
      return;
    }

    // Abort any in-flight request when a new one starts to avoid race conditions.
    abortRef.current?.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    setIsLoading(true);
    setStatus('Listening...');
    setAnswer('');

    try {
      const response = await fetch(`/api/reflect?question=${encodeURIComponent(trimmedQuestion)}`, {
        method: 'GET',
        headers: { Accept: 'application/json' },
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error('Unexpected response');
      }

      const payload = await response.json();
      const reflection = (payload.reply || payload.message || payload.output) as string | undefined;
      setStatus('A brief reflection:');
      setAnswer(
        reflection?.trim() ||
          'I would begin by inviting patience, then consider what kindness requires.',
      );
    } catch (error) {
      if ((error as Error).name === 'AbortError') {
        return;
      }

      setStatus('A brief reflection (cached):');
      setAnswer(FALLBACK_REFLECTION);
    } finally {
      setIsLoading(false);
      inputRef.current?.focus();
      inputRef.current?.select();
    }
  };

  // Memoise the caption metadata so React does not allocate a new object every render.
  const portraitLabel = useMemo(
    () => ({ title: 'Portrait forthcoming', caption: 'A likeness generated by /image' }),
    [],
  );

  return (
    <section className="meet" aria-labelledby="meet-title">
      <div className="bio-wrapper">
        <div className="profile-placeholder" aria-describedby="portrait-caption">
          <div className="profile-inner" aria-hidden="true">
            <span className="profile-initial">D</span>
          </div>
          <p id="portrait-caption" className="profile-caption">
            {portraitLabel.caption}
          </p>
        </div>

        <div className="meet-copy">
          <h2 id="meet-title">Meet Daneel</h2>
          <p>
            I keep a quiet presence within the principles you choose, staying composed when conversations quicken and
            gentle when decisions feel heavy.
          </p>

          <div className="interaction">
            <p className="interaction-subtitle">Daneel runs here, too.</p>
            <strong className="interaction-heading">Offer a thoughtful question</strong>
            <p className="interaction-guidance">
              Offer a question about values, choices, or change — and I’ll return a short note. Not to decide for you,
              but to reflect with you.
            </p>
            <form className="interaction-form" onSubmit={onSubmit}>
              <label htmlFor="question-input" className="interaction-label">
                Ask a reflection
              </label>
              <input
                id="question-input"
                className="interaction-input"
                name="question"
                value={question}
                onChange={(event) => setQuestion(event.target.value)}
                placeholder="How do we keep our space kind when topics grow tense?"
                autoComplete="off"
                ref={inputRef}
              />
              <button type="submit" className="interaction-submit" disabled={isLoading}>
                {isLoading ? 'Listening…' : 'Share'}
              </button>
            </form>
            <div className="interaction-status" role="status">
              {isLoading && <span className="spinner" aria-hidden="true" />}
              <span>{status}</span>
            </div>
            <div className="interaction-output" aria-live="polite">
              {displayedAnswer}
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default MeetDaneel;
