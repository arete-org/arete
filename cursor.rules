# ARETE Development Rules
# These guide both human contributors and AI tools (Cursor, Traycer)
# toward traceable, ethics-aligned, maintainable code.

## Code Quality
- Use the structured logger (`utils/logger.ts`) for all logs.
- Default to `async/await` for clarity, but use `.then()` or `Promise.all()` when parallelism or lazy chaining improves performance.
- Wrap risky operations in `try/catch` with informative error messages.
- Follow existing naming conventions for consistency.

## TypeScript Standards
- Use explicit types everywhere; avoid `any`.
- Use `interface` for public or extendable structures; use `type` for unions, aliases, or generics.
- Enable and honor strict null checks.
- Use generics thoughtfully when they clarify intent.

## Commenting Standards
- **Always include meaningful comments** - AI assistants tend to avoid comments, but they're essential for collaboration and learning.
- Comments serve as documentation for future maintainers and community contributors.
- Prioritize comments that explain "why" and "what", not just "how".
- Write comments for competent developers - focus on knowledge transfer, not basic explanations.

### **Code Comments (// and /* */)**
- Add comments for complex business logic, non-obvious algorithms, or important decisions.
- Explain the reasoning behind implementation choices, especially when there are alternatives.
- Document workarounds, edge cases, and potential gotchas.
- Include context about external dependencies or API behaviors.
- Use parenthetical explanations for technical terms: `technicalTerm (plainEnglish)`.

**Good Code Comments:**
```typescript
// Reset the counter when we post a message to prevent catch-up loops
if (message.author.id === message.client.user!.id) {
    this.resetCounter(channelKey);
    return;
}

// Apply catch-up filter to avoid unnecessary LLM calls during message floods (rapid-fire messages)
const filterDecision = await this.catchupFilter.shouldSkipPlanner(message, recentMessages, channelKey);

// Use fail-open design (don't block execution when uncertain)
if (!this.config.enabled) {
    return;
}
```

**Avoid Basic Explanations:**
```typescript
// Increment the counter by 1
counter++;

// Set the value to true
enabled = true;
```

### **JSDoc Documentation**
- Apply JSDoc strategically based on context and value, not universally.
- Use JSDoc for interfaces/types that benefit from hover documentation and AI assistant context.
- Focus on complex types, public APIs, and interfaces where understanding the "why" matters.
- Skip JSDoc for simple, self-explanatory types where the property names are clear.

**When to use JSDoc:**
- Public interfaces that other modules will use
- Complex types with business logic or non-obvious relationships
- Types where hover documentation helps developers understand requirements
- Interfaces that benefit AI assistants for better context understanding

**When to skip JSDoc:**
- Simple, self-explanatory interfaces where property names are clear
- Internal types that are obvious from context
- Types that are just data containers without business meaning

**Good JSDoc Example:**
```typescript
/**
 * Core cost breakdown for any model type
 * @interface CostBreakdown
 * @property {number} inputTokens - Tokens consumed from the input prompt (user message, context, etc.)
 * @property {number} outputTokens - Tokens generated in the AI response
 * @property {number} inputCost - Cost for processing input tokens (typically cheaper)
 * @property {number} outputCost - Cost for generating output tokens (typically more expensive)
 * @property {number} totalCost - Combined cost of input + output processing
 */
```

**Skip JSDoc for simple types:**
```typescript
export interface SimpleConfig {
    enabled: boolean;
    timeout: number;
    retries: number;
}
```

## ARETE Framework Principles
- Reuse existing utilities (`logger.ts`, `env.ts`, `pricing.ts`, `openaiService.ts`) before adding new modules.
- Every LLM interaction must record tokens and cost via `ChannelContextManager.recordLLMUsage()`.
- All buffers are RAM-only (no persistence to disk or database).
- Follow fail-open design: if uncertain, don’t block execution.
- Log every decision at debug level with structured data.
- Keep all public interfaces serializable for future web UI integration (e.g., Cognitive Budget panel).

## ARETE Module Tagging
- Every module must include structured ARETE annotations in its JSDoc header.
- Use this format for consistency and machine-parseability:

```typescript
/**
 * @arete-module: <ModuleName>
 * @arete-risk: <critical|high|moderate|low>
 * @arete-ethics: <critical|high|moderate|low>
 * @arete-scope: <core|utility|interface|test>
 * 
 * @description
 * <1-3 lines summarizing what this module does.>
 * 
 * @impact
 * Risk: <What could break or be compromised if mishandled.>
 * Ethics: <What human or governance impacts errors could cause.>
 */
```

- **@arete-risk**: Technical fragility (stability, security, data integrity)
- **@arete-ethics**: Human/governance impact (privacy, fairness, transparency, social harm)
- **@arete-scope**: Logical role in the system (helps auto-group modules)
- Run `pnpm validate-arete-tags` before committing; CI enforces this to guarantee standardized risk/ethics levels.
- Keep annotations under 10 lines for readability
- Separate technical risk from ethical sensitivity for clarity
- Enable future automated audit tools (e.g., `pnpm audit-risk`)

## ARETE Scoped Logger Tagging
- Every scoped logger must include structured ARETE annotations in its JSDoc header.
- Use this format for consistency and machine-parseability:

```typescript
/**
 * @arete-logger: <loggerName>
 * 
 * @logs
 * <What this scoped logger tracks and logs>
 * 
 * @impact
 * Risk: <Logging-specific risks if any>
 * Ethics: <Logging-specific ethical impacts if any>
 */
const <loggerName>Logger = logger.child({ module: '<loggerName>' });
```

- **@arete-logger**: Logger module identifier (matches the child logger name)
- **@logs**: What specific operations, events, or data this logger logs
- Follow the same formatting standards as module headers for consistency

## Code Changes
- Prefer small, well-scoped diffs.
- Preserve provenance comments, cost tracking, and licensing headers.
- Never remove risk annotations or audit metadata without explicit reason.
- Maintain backward compatibility unless explicitly breaking for a versioned release.

## Pre-Review Analysis with Cursor
- **Use Cursor for structural pre-review** before human code review to catch complexity, inconsistencies, and missing documentation.
- This augments human review by focusing on mechanical thoroughness while preserving human judgment for logic, ethics, and integration decisions.
- **Prerequisites**: Always run `npm run pre-review` first to ensure ARETE-specific validation passes before Cursor analysis.

### Complexity Triage
- Prompt Cursor to identify functions that do too many things, deep conditionals, or unclear data flow.
- Flag areas that need human scrutiny versus easy cleanup opportunities.
- Use Cursor's Bugbot (Review PR) or Explain Changes features to get structural analysis.
- Use inline chat (`Ctrl+K`) to ask specific questions about complex code sections.

### Comment Scaffolding
- Prompt Cursor to "add comments where a new contributor would hesitate."
- Focus on teachability and knowledge transfer for open-source collaboration.
- Ensure comments explain "why" and "what", not just "how" (see Commenting Standards above).

### Future-Thinking Analysis
- Use Cursor's inline chat to explore forward-compatibility questions:
  - "Would this API boundary survive a modular ethics-core refactor?"
  - "Can this function be generalized for multi-lens reasoning?"
  - "How would this scale with additional model providers?"
- Seed lightweight architectural review before merge decisions.

### Consistency Enforcement
- Ensure doc comments and logging consistently follow ARETE provenance schema (risk tiers, license context, etc.).
- Verify ARETE module tagging compliance across new code.
- Check that structured logging patterns are maintained.

### Recommended Workflow
1. **Complete implementation**
2. **Run automated validation**: `npm run pre-review` (validates ARETE tags, types, linting)
3. **Use Cursor's Bugbot (Review PR)** for automated code quality analysis
4. **Use inline chat (`Ctrl+K`)** with ARETE-specific prompts (see `.cursor/arete-prompts.md`)
5. **Run ethics/risk audits**: `npm run ethics-check && npm run risk-check`
6. **Accept suggested simplifications or comments** in-place
7. **Open human PR review** for logic, ethics, and integration focus

### Integration with Existing Tools
- **Pre-review pipeline**: `npm run pre-review` → `npm run full-pre-review`
- **ARETE validation**: `npm run validate-arete-tags` (enforced by CI)
- **Cursor tasks**: Use `.cursor/tasks.json` commands for quick access
- **Checklist**: Follow `.cursor/pre-review-checklist.md` before Cursor analysis
- **Prompts**: Use `.cursor/arete-prompts.md` for consistent, effective Cursor interactions

## Testing
- Add or update tests for any new functionality.
- Follow existing test utilities and patterns.
- Tests must be deterministic; mock external services where possible.
