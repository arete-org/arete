# ARETE Development Rules
# These guide both human contributors and AI tools (Cursor, Traycer)
# toward traceable, ethics-aligned, maintainable code.

## Code Quality
- Use the structured logger (`utils/logger.ts`) for all logs.
- Default to `async/await` for clarity, but use `.then()` or `Promise.all()` when parallelism or lazy chaining improves performance.
- Wrap risky operations in `try/catch` with informative error messages.
- Follow existing naming conventions for consistency.

## TypeScript Standards
- Use explicit types everywhere; avoid `any`.
- Use `interface` for public or extendable structures; use `type` for unions, aliases, or generics.
- Enable and honor strict null checks.
- Use generics thoughtfully when they clarify intent.

## Commenting Standards
- **Always include meaningful comments** - AI assistants tend to avoid comments, but they're essential for collaboration and learning.
- Comments serve as documentation for future maintainers and community contributors.
- Prioritize comments that explain "why" and "what", not just "how".
- Write comments for competent developers - focus on knowledge transfer, not basic explanations.

### **Code Comments (// and /* */)**
- Add comments for complex business logic, non-obvious algorithms, or important decisions.
- Explain the reasoning behind implementation choices, especially when there are alternatives.
- Document workarounds, edge cases, and potential gotchas.
- Include context about external dependencies or API behaviors.
- Use parenthetical explanations for technical terms: `technicalTerm (plainEnglish)`.

**Good Code Comments:**
```typescript
// Reset the counter when we post a message to prevent catch-up loops
if (message.author.id === message.client.user!.id) {
    this.resetCounter(channelKey);
    return;
}

// Apply catch-up filter to avoid unnecessary LLM calls during message floods (rapid-fire messages)
const filterDecision = await this.catchupFilter.shouldSkipPlanner(message, recentMessages, channelKey);

// Use fail-open design (don't block execution when uncertain)
if (!this.config.enabled) {
    return;
}
```

**Avoid Basic Explanations:**
```typescript
// Increment the counter by 1
counter++;

// Set the value to true
enabled = true;
```

### **JSDoc Documentation**
- Apply JSDoc strategically based on context and value, not universally.
- Use JSDoc for interfaces/types that benefit from hover documentation and AI assistant context.
- Focus on complex types, public APIs, and interfaces where understanding the "why" matters.
- Skip JSDoc for simple, self-explanatory types where the property names are clear.

**When to use JSDoc:**
- Public interfaces that other modules will use
- Complex types with business logic or non-obvious relationships
- Types where hover documentation helps developers understand requirements
- Interfaces that benefit AI assistants for better context understanding

**When to skip JSDoc:**
- Simple, self-explanatory interfaces where property names are clear
- Internal types that are obvious from context
- Types that are just data containers without business meaning

**Good JSDoc Example:**
```typescript
/**
 * Core cost breakdown for any model type
 * @interface CostBreakdown
 * @property {number} inputTokens - Tokens consumed from the input prompt (user message, context, etc.)
 * @property {number} outputTokens - Tokens generated in the AI response
 * @property {number} inputCost - Cost for processing input tokens (typically cheaper)
 * @property {number} outputCost - Cost for generating output tokens (typically more expensive)
 * @property {number} totalCost - Combined cost of input + output processing
 */
```

**Skip JSDoc for simple types:**
```typescript
export interface SimpleConfig {
    enabled: boolean;
    timeout: number;
    retries: number;
}
```

## ARETE Framework Principles
- Reuse existing utilities (`logger.ts`, `env.ts`, `pricing.ts`, `openaiService.ts`) before adding new modules.
- Every LLM interaction must record tokens and cost via `ChannelContextManager.recordLLMUsage()`.
- All buffers are RAM-only (no persistence to disk or database).
- Follow fail-open design: if uncertain, donâ€™t block execution.
- Log every decision at debug level with structured data.
- Keep all public interfaces serializable for future web UI integration (e.g., Cognitive Budget panel).

## ARETE Module Tagging
- Every module must include structured ARETE annotations in its JSDoc header.
- Use this format for consistency and machine-parseability:

```typescript
/**
 * @arete-module: <ModuleName>
 * @arete-risk: <critical|high|moderate|low>
 * @arete-ethics: <critical|high|moderate|low>
 * @arete-scope: <core|utility|interface|test>
 * 
 * @description
 * <1-3 lines summarizing what this module does.>
 * 
 * @impact
 * Risk: <What could break or be compromised if mishandled.>
 * Ethics: <What human or governance effect errors could cause.>
 */
```

- **@arete-risk**: Technical fragility (stability, security, data integrity)
- **@arete-ethics**: Human/governance impact (privacy, fairness, transparency, social harm)
- **@arete-scope**: Logical role in the system (helps auto-group modules)
- Run `pnpm validate-arete-tags` before committing; CI enforces this to guarantee standardized risk/ethics levels.
- Keep annotations under 10 lines for readability
- Separate technical risk from ethical sensitivity for clarity
- Enable future automated audit tools (e.g., `pnpm audit-risk`)

## ARETE Scoped Logger Tagging
- Every scoped logger must include structured ARETE annotations in its JSDoc header.
- Use this format for consistency and machine-parseability:

```typescript
/**
 * @arete-logger: <loggerName>
 * 
 * @logs
 * <What this scoped logger tracks and logs>
 * 
 * @impact
 * Risk: <Logging-specific risks if any>
 * Ethics: <Logging-specific ethical impacts if any>
 */
const <loggerName>Logger = logger.child({ module: '<loggerName>' });
```

- **@arete-logger**: Logger module identifier (matches the child logger name)
- **@logs**: What specific operations, events, or data this logger logs
- Follow the same formatting standards as module headers for consistency

## Code Changes
- Prefer small, well-scoped diffs.
- Preserve provenance comments, cost tracking, and licensing headers.
- Never remove risk annotations or audit metadata without explicit reason.
- Maintain backward compatibility unless explicitly breaking for a versioned release.

## Testing
- Add or update tests for any new functionality.
- Follow existing test utilities and patterns.
- Tests must be deterministic; mock external services where possible.
